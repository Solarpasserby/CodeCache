## Month1

#### Question1

- **时间复杂度**

  - **定义**

    算法的时间复杂度是指算法运行时间随输入数据规模增长而变化的趋势。

  - **举例**

    1. 常数时间复杂度$O(1)$，代表算法的运行时间与数据规模大小无关，为定值。例如栈的出栈入栈操作；
    2. 对数时间复杂度$O(\log n)$，代表算法的运行时间与数据规模呈对数关系，当数据规模线性增长时，运行时间增长相对缓慢。例如平衡二叉树的搜索、插入操作。
    3. 线性时间复杂度$O(\log n)$，代表算法的运行时间与数据规模呈线性关系，二者成正比。例如遍历数组操作。
    4. 平方时间复杂度$O(n^2)$，代表算法的运行时间与数据规模呈平方关系，当数据规模线性增长时，运行时间以平方的速度快速增长。例如冒泡排序、选择排序。

- **空间复杂度**

  - **定义**
  
    空间复杂度是指算法执行过程中所需的内存空间随输入规模增长的趋势。
  
  - **举例**
  
    1. 常数空间$O(1)$，代表算法仅使用固定大小的内存空间。例如常量。
    2. 线性空间$O(n)$，代表算法使用的内存空间与数据规模成正比。例如数组。

#### Question2

**BFS**适合求解最短路径、层次结构等问题。**DFS**适合求较深解空间树的问题。

#### Question3

```c++
set<int> st;
void example(vector<int>& arr) {
    for(int i = 0; i < arr.size(); i++) {
        for(int j = i + 1; j < arr.size(); j++) {
            if (arr[i] == arr[j] && st.count(arr[i]) == 0) {
                st.insert(arr[i]);
                cout << arr[i] << " ";
            }
        }
    }
}
```

观察以上代码，发现存在两层循环。第一层循环遍历`arr`中的所有元素，重复$n$次。第二层循环遍历剩余元素。每一次内部循环对`st`进行一次查找和一次插入，最坏情况下消耗$2\cdot \log(n)$的运行步数。因此总体时间复杂度为$O(n^2\log n)$，时间复杂度较大。

注意到以上代码存在部分冗余，先给出以下优化算法。删去了第二层循环，不再是将剩余元素一一与当前元素进行对比，而是直接尝试将元素插入`st`中。若成功插入，代表元素未出现过，则输出，否则跳过。通过利用`insert`方法的返回值，可以实现对集合`st`的一次访问，进一步节省时间。综上，优化后的时间复杂度为$O(n\log n)$，相对可观。

```c++
set<int> st;
void example(vector<int>& arr) {
 for(int i = 0; i < arr.size(); i++)
     if (st.insert(arr[i]).second)
         cout << arr[i] << " ";
}
```

#### Question4

假设安排$n$次互不冲突的会议的区间右值最小值为$M_t$。显然，$M_1$当且仅当选取结束时间最小的会议。对于$M_{t+1}$，必然有$M_{t+1}=\min(\{b_i|\forall [a_i, b_i]\in S, ai\geq M_t\})$。利用数学归纳法可以证明可以使用贪心策略求得$M_t$。要解决题目，即找出不大于$n$的最大$M_t$便可。
