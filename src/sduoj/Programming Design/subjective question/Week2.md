## Week2

### Question1

`std::set.insert`方法的时间复杂度为$O(\log n)$，由于进行了$n$次循环，因此$f_1$总体的时间复杂度为$O(n \log n)$

使用迭代器遍历整个集合`s`，因此$f_2$的时间复杂度为$O(n)$

------

### Question2

由于输入的字符串长度为$m$，可以知道最坏情况下字符串比较的时间复杂度为$O(m)$。使用`std::sort`进行排序，比较次数约为$n log {n}$，因此总体时间复杂度为$O(mn\log n)$

------

### Question3

`std::sort`实现的是在一段连续的空间内，依照给定规则，实现对数据的排序，适用于数组、向量容器等存储空间连续的数据结构。而`std::list`是链式结构，存储空间不连续，无法使用`std::sort`实现数据的排序，因此需要一个适用于自身的`sort`成员函数

------

### Question4

`std::find`函数需要遍历给定的数据段才能判断所寻找数据是否存在，最坏情况下时间复杂度为$O(n)$，而`std::set`和`std::map`都是基于搜索树（红黑树）实现的，这类数据结构能有更高的效率来查找给定数据，一般情况下时间度为$O(\log n)$，在数据量较大的情况下，后者的查找速率远远高于前者，因此利用`std::set`和`std::map`的`find`方法可以提升程序的效率

------

### Question5

可以通过自定义比较方法来实现

```c++
struct myCmp {
    bool operator()(int a, int b) const { return a > b; }
}

set<int, myCmp> s;
```

